# 第九课：提示词优化技巧 - 效率提升 10 倍的秘诀

> 🎯 **学习目标**：掌握高效的提示词技巧，让开发效率提升 10 倍

## 1. 为什么提示词如此重要？

### 提示词 = AI 编程的新语言

在传统编程时代，我们用编程语言和计算机对话。在 AI 时代，**提示词就是新的编程语言**，它决定了 AI 的输出质量。

**对比实验**：

❌ **糟糕的提示词**：
```
做一个网站
```
- 需要 10-15 轮对话
- 结果可能不符合预期
- 浪费大量时间

✅ **优秀的提示词**：
```
创建一个响应式的电商产品展示页面，要求：

功能需求：
- 产品网格布局（桌面3列，平板2列，手机1列）
- 每个产品卡片包含：图片（16:9）、标题、价格、评分、"加入购物车"按钮
- 鼠标悬停时卡片上浮并显示阴影效果
- 点击产品跳转到详情页

技术要求：
- 使用 HTML5 + CSS3（Flexbox/Grid）
- 原生 JavaScript，不使用框架
- 支持 IE11+ 的现代浏览器

设计风格：
- 简约现代风格
- 主色调：#3498db（蓝色）
- 卡片圆角：8px
- 使用 Google Fonts - Roboto 字体
```
- 1-3 轮对话即可完成
- 结果精准符合需求
- 节省 80% 时间

**关键洞察**：提示词的质量直接决定了 AI 的输出质量和开发效率。

## 2. 提示词优化的六大黄金原则

### 原则 1：具体明确 (Specific)

**核心理念**：让 AI 知道你要什么，而不是猜你要什么。

#### 对比示例

❌ **模糊表达**：
```
帮我优化这个函数
```

✅ **具体明确**：
```
优化这个数据处理函数，要求：
1. 减少时间复杂度（当前 O(n²)，目标 O(n log n)）
2. 使用更现代的 ES6+ 语法（箭头函数、解构等）
3. 添加输入验证（检查 null、undefined、空数组）
4. 保持原有功能不变（不改变返回值格式）
5. 添加详细的 JSDoc 注释（参数类型、返回值、示例）
```

#### 实战公式

```
[动作] + [对象] + [具体要求] + [约束条件] + [预期结果]
```

**示例应用**：
```
重构 UserService 类的 getUserData 方法，
使用 async/await 替代 Promise.then 链式调用，
添加错误重试机制（最多重试3次，间隔1秒），
保持 API 接口签名不变，
返回标准化的 { success, data, error } 格式
```

#### 练习

将以下模糊提示词改写为具体明确的版本：

1. "创建一个按钮"
2. "修复这个 bug"
3. "添加验证"

### 原则 2：结构化 (Structured)

**核心理念**：用清晰的结构组织信息，让 AI 快速理解重点。

#### 推荐结构模板

```markdown
## 背景
[说明当前情况和问题]

## 目标
[明确要达成的目标]

## 要求
1. [功能要求]
2. [技术要求]
3. [性能要求]
4. [兼容性要求]

## 约束
- [时间/资源限制]
- [技术栈限制]
- [兼容性要求]

## 参考
[提供示例或参考资料]
```

#### 实战案例

```markdown
## 背景
现有登录系统使用 Session 存储认证状态，
但需要支持移动端 App 和多设备同时登录，
Session 方案无法满足需求。

## 目标
将认证系统改造为 JWT 令牌机制

## 要求
1. 功能要求：
   - 支持令牌刷新机制（双令牌模式）
   - 支持多设备同时登录
   - 支持令牌黑名单（实现登出功能）
   - 支持令牌失效检测

2. 技术要求：
   - 使用 jsonwebtoken 库
   - 访问令牌有效期：15分钟
   - 刷新令牌有效期：7天
   - 使用 Redis 存储刷新令牌和黑名单

3. 安全要求：
   - 令牌签名使用 RS256 算法（非对称加密）
   - 敏感信息（密码、手机号）不放入令牌
   - 实现 CSRF 防护
   - 添加 IP 地址验证

## 约束
- 不能破坏现有 API 接口（保持向下兼容）
- 需要支持旧客户端逐步迁移（双模式并行）
- 数据库结构尽量不改动
- 部署不能影响线上服务

## 参考
- 参考 Auth0 的令牌管理机制
- 参考 OAuth 2.0 刷新令牌流程
```

**为什么结构化重要？**
- 信息层次清晰
- AI 能准确抓住重点
- 减少误解和返工
- 便于后续维护和修改

### 原则 3：上下文丰富 (Contextual)

**核心理念**：提供足够的背景信息，让 AI 做出更合适的决策。

#### 上下文信息清单

```markdown
✅ 应该提供的上下文：
- 项目类型（Web应用/移动App/桌面软件等）
- 项目规模（用户量、数据量、团队规模）
- 技术栈和版本（具体到版本号）
- 团队技能水平（初级/中级/高级）
- 现有代码结构（架构模式、目录组织）
- 业务场景（ToB/ToC、行业特点）
- 用户群体（年龄层、设备、网络环境）
- 性能要求（响应时间、并发量）
- 预算和时间限制

❌ 不必要的信息：
- 过于详细的公司背景
- 与技术无关的个人信息
- 冗余的描述
- 无关紧要的细节
```

#### 实战案例

**案例 1：视频播放器开发**

```markdown
## 项目上下文
- 项目：在线教育平台的视频播放器组件
- 技术栈：React 18.2 + TypeScript 5.0 + Video.js 8.0
- 项目规模：
  - 日活用户：5万+
  - 视频库：10TB+，单视频平均 500MB
  - 前端团队：3人，都熟悉 React，TS 基础一般
- 现状：
  - 当前使用原生 Video.js
  - 功能简单，缺少定制
  - 用户反馈体验不好
- 用户画像：
  - 70% 移动端用户（iOS/Android）
  - 网络环境不稳定（4G/WiFi切换频繁）
  - 观看场景：通勤、碎片时间
- 性能要求：
  - 首屏加载 < 3秒
  - 播放流畅，卡顿率 < 5%
  - 切换清晰度无感知

## 任务
设计一个视频播放器组件架构，要考虑：
1. 移动端优化和自适应（手势控制、竖屏适配）
2. 弱网环境下的流畅播放（自适应码率、预加载）
3. 播放数据统计（观看时长、完成率、卡顿次数）
4. 易于扩展新功能（弹幕、倍速、字幕、PiP）
5. TypeScript 类型安全
```

**为什么这个上下文好？**
- AI 知道用户主要用移动端 → 会优先考虑移动端优化
- AI 知道网络不稳定 → 会建议自适应码率和缓存策略
- AI 知道团队 TS 基础一般 → 不会用太高级的 TS 特性
- AI 知道性能要求 → 会注重首屏加载和流畅度

### 原则 4：示例驱动 (Example-driven)

**核心理念**：一个好的示例胜过千言万语。

#### 三种示例类型

**1. 代码示例**

```markdown
当前代码（有问题）：
```javascript
function getData() {
  return fetch('/api/data')
    .then(res => res.json())
    .then(data => data)
}
```

期望改为：
- 使用 async/await 语法（更易读）
- 添加完整的错误处理（网络错误、HTTP错误、JSON解析错误）
- 添加 loading 状态管理
- 添加请求超时控制（10秒超时）
- 添加请求取消功能（组件卸载时）

期望的代码风格：
```javascript
async function getData(signal) {
  try {
    // 清晰的注释
    // 完整的错误处理
    // 统一的返回格式
  } catch (error) {
    // 友好的错误提示
  }
}
```
```

**2. UI 参考示例**

```markdown
创建一个全局通知组件，参考以下设计：

视觉效果：
- 样式参考 Ant Design 的 Message 组件
- 或者类似于 GitHub 顶部的通知横幅
- 参考链接：https://ant.design/components/message-cn/

交互行为：
- 从顶部滑入（动画时长 300ms，缓动函数 ease-out）
- 自动消失（默认 3秒，可配置）
- 可以手动关闭（点击右侧 X 按钮）
- 同时最多显示 3 条（超出的排队等待）

功能要求：
- 支持 4 种类型：success / warning / error / info
- 每种类型有对应的图标和颜色
- 支持自定义图标
- 支持自定义时长
- 支持自定义位置（顶部/底部）
- 支持 HTML 内容（但需要防 XSS）

API 设计：
```javascript
// 简单用法
message.success('操作成功！')

// 复杂用法
message.warning({
  content: '网络连接不稳定',
  duration: 5000,
  icon: <IconWifi />,
  onClose: () => console.log('closed')
})
```
```

**3. 数据结构示例**

```markdown
## 后端 API 返回的数据格式

```json
{
  "code": 200,
  "message": "success",
  "data": {
    "list": [
      {
        "id": 1001,
        "username": "张三",
        "email": "zhangsan@example.com",
        "age": 25,
        "role": "admin",
        "createdAt": "2024-01-15T08:30:00Z",
        "profile": {
          "avatar": "https://cdn.example.com/avatar/1001.jpg",
          "bio": "全栈开发工程师"
        }
      }
    ],
    "pagination": {
      "total": 1000,
      "page": 1,
      "pageSize": 10,
      "totalPages": 100
    }
  },
  "timestamp": 1704523800000
}
```

## 任务
请为这个 API 响应：
1. 创建完整的 TypeScript 类型定义
2. 创建数据处理函数（提取、转换、验证）
3. 创建错误处理逻辑
4. 添加使用示例
```

#### 为什么示例重要？

- **消除歧义**：文字描述可能有多种理解，示例只有一种
- **提高准确度**：AI 能精确理解你的需求
- **节省时间**：减少反复沟通和修改
- **统一标准**：确保输出符合项目规范

### 原则 5：迭代式 (Iterative)

**核心理念**：分步骤完成，逐步完善，而不是一次性要求所有功能。

#### 推荐的迭代流程

```
第一步：最小可用版本 (MVP)
"创建一个用户列表页面，显示用户名、邮箱、注册时间"
→ 验证基本功能

第二步：基础交互
"添加搜索功能，可以按用户名搜索"
→ 验证搜索逻辑

第三步：高级功能
"添加分页（每页10条）、排序（按注册时间/用户名）和筛选（按角色）功能"
→ 验证复杂交互

第四步：性能优化
"优化性能，使用虚拟滚动处理大量数据（1万+ 用户）"
→ 验证性能

第五步：体验完善
"添加批量操作（批量删除、导出 Excel）和骨架屏加载"
→ 验证完整体验
```

#### 实战对话示例

```
👤 你：创建一个基础的登录页面，包含用户名和密码输入框，以及登录按钮

🤖 Claude：[创建基础登录页面 HTML + CSS + JS]

👤 你：很好！现在添加表单验证：
- 用户名：必填，3-20个字符，只能包含字母数字下划线
- 密码：必填，8-20个字符，至少包含大小写字母和数字

🤖 Claude：[添加表单验证逻辑]

👤 你：完美！现在添加"记住我"功能，勾选后7天内自动登录

🤖 Claude：[添加记住我功能，使用 localStorage]

👤 你：很好！最后添加第三方登录（Google 和 GitHub），使用 OAuth 2.0

🤖 Claude：[添加第三方登录按钮和 OAuth 流程]

👤 你：完美！现在优化一下样式，参考 Dribbble 的现代登录页设计

🤖 Claude：[优化视觉设计]
```

#### 迭代式开发的优势

- ✅ **及时验证**：每步都能测试，发现问题立即修正
- ✅ **方向可调**：根据实际情况灵活调整
- ✅ **降低风险**：避免大规模返工
- ✅ **提高质量**：每步打磨精细
- ✅ **学习成长**：逐步理解项目全貌

### 原则 6：反馈式 (Feedback-driven)

**核心理念**：给予明确的反馈，训练 AI 理解你的偏好。

#### 三种反馈类型

**1. 正面反馈** 💚

```
✅ 很好！这正是我想要的
✅ 完美！继续按这个思路
✅ 这个方案很棒，实现得很优雅
✅ 太赞了！性能提升很明显
✅ 很专业！代码质量很高
```

**2. 建设性反馈** 💛

```
⚠️ 方向对了，但是可以更简洁一些
⚠️ 功能实现了，但性能可能有问题（数据量大时会卡）
⚠️ 思路不错，但不符合我们的编码规范（需要用 ESLint）
⚠️ 代码可以工作，但可读性需要提升（加些注释）
⚠️ 基本正确，但边界情况没考虑（空数组、null 值）
```

**3. 纠正性反馈** 💔

```
❌ 这不是我想要的，我的意思是...
❌ 你理解错了，让我重新描述一下...
❌ 这个方案太复杂了，我需要更简单的实现
❌ 方向完全错了，应该是...
❌ 这个不符合需求，请重新设计
```

#### 有效反馈示例

**场景：创建数据表格**

```
👤 你：创建一个数据表格组件，显示用户数据

🤖 Claude：[创建了一个功能丰富的表格：排序、筛选、分页、导出等]

👤 你：❌ 功能太多了，现在我只需要最基础的功能：
1. 显示数据（行和列）
2. 简单的样式（斑马纹、边框）
3. 不需要排序、筛选、分页等高级功能
请删除所有复杂功能，保持最简单的实现

🤖 Claude：[创建简化版本，只有基础表格]

👤 你：✅ 好多了！现在在这个基础上添加两个小功能：
1. 点击行时高亮显示（添加背景色）
2. 鼠标悬停时显示完整内容的 tooltip（因为单元格可能显示不全）

🤖 Claude：[添加这两个功能]

👤 你：✅ 完美！这正是我需要的，代码也很简洁易读
```

**为什么反馈重要？**

- AI 会学习你的偏好
- 减少误解和返工
- 快速收敛到最佳方案
- 建立更好的协作模式

## 3. 高级提示词技巧

### 技巧 1：角色设定

**理论**：让 Claude Code 扮演特定领域的专家，获得更专业的输出。

#### 示例 1：前端架构师

```
你现在是一位资深的前端架构师，拥有 10 年大型 Web 应用开发经验。
你深刻理解性能优化、可维护性、可扩展性的平衡之道。

背景：我们要开发一个大型电商网站（预期日活 100万+）

请帮我设计前端架构，需要考虑：
1. 技术选型（框架、状态管理、构建工具）
2. 工程化方案（代码规范、Git 工作流、CI/CD）
3. 性能优化策略（首屏、白屏、运行时性能）
4. 可维护性设计（目录结构、组件设计、文档规范）
5. 团队协作（10人前端团队，水平参差不齐）
6. 技术债务管理（如何避免和偿还）

请给出详细的设计方案，包括技术选型理由和实施路线图。
```

#### 示例 2：性能优化专家

```
你现在是一位性能优化专家，精通前端性能分析和优化。

我的 React 应用有严重的性能问题：
- 首屏加载时间：5秒（目标 < 2秒）
- LCP：3.8秒（目标 < 2.5秒）
- FID：200ms（目标 < 100ms）
- 大量不必要的组件重渲染
- Bundle 体积：8MB（未压缩）

技术栈：
- React 18 + TypeScript
- Webpack 5
- 大量第三方库（Ant Design、ECharts、Moment.js等）

请帮我：
1. 分析性能瓶颈（从数据看问题）
2. 制定优化方案（按优先级排序）
3. 提供具体的优化代码
4. 预估优化效果
```

#### 示例 3：安全专家

```
你现在是一位 Web 安全专家，对 OWASP Top 10 了如指掌。

请对我的用户认证系统进行安全审查：

[贴上认证相关代码]

审查重点：
1. SQL 注入风险
2. XSS 攻击风险
3. CSRF 攻击风险
4. 密码存储安全
5. Session 管理安全
6. 敏感信息泄露
7. 暴力破解防护
8. 越权访问风险

请给出：
1. 安全问题清单（按严重程度排序）
2. 每个问题的具体修复方案
3. 修复后的安全代码
4. 安全最佳实践建议
```

**角色设定的好处**：
- AI 会以该角色的视角思考
- 输出更专业、更深入
- 考虑问题更全面
- 建议更有针对性

### 技巧 2：思维链 (Chain of Thought)

**理论**：引导 AI 分步思考，而不是直接给答案，得到更好的解决方案。

#### 模板

```
请按以下步骤分析并解决问题：

1. 首先，理解和分析当前问题
   - 问题的本质是什么？
   - 有哪些关键约束？

2. 然后，列出所有可能的解决方案（至少 3 个）
   - 方案 A：[描述]
   - 方案 B：[描述]
   - 方案 C：[描述]

3. 接着，比较各方案的优缺点
   - 从性能、复杂度、可维护性等维度对比

4. 之后，推荐最佳方案并说明理由

5. 最后，实现推荐方案
   - 提供完整代码
   - 添加详细注释
   - 包含使用示例

问题：[描述你的问题]
```

#### 实战案例

```
问题：用户登录后，仪表板页面加载很慢（首次加载 5 秒+）

请按以下步骤分析：

1. 列出可能导致慢的原因（至少 5 个）
2. 分析每个原因的可能性（高/中/低）
3. 提供诊断方法（如何验证是这个原因）
4. 给出针对性的优化方案
5. 实现最重要的 3 个优化
6. 预估优化后的加载时间

技术栈：React + Redux + TypeScript
页面特点：包含多个图表（ECharts）、实时数据、大量列表
```

**思维链的好处**：
- 决策过程透明
- 考虑更全面
- 方案更优
- 可以从推理过程学习

### 技巧 3：约束性提示

**理论**：明确告知不能做什么，避免过度设计和不必要的复杂度。

#### 示例

```
创建一个待办事项应用（Todo App），要求：

✅ 要做的：
- 添加、删除、编辑任务
- 标记任务完成/未完成
- 本地存储数据（LocalStorage）
- 简单清爽的 UI

❌ 不要做的：
- 不要使用任何框架（只用原生 JS + HTML + CSS）
- 不要添加用户认证功能
- 不要使用后端 API
- 不要使用复杂的状态管理
- 不要添加拖拽排序等高级功能
- 不要过度设计（保持代码简单）

代码要求：
- 单个 HTML 文件
- 内联 CSS 和 JS（便于演示）
- 总代码量 < 300 行
- 不要使用构建工具
```

**约束的好处**：
- 避免过度工程
- 聚焦核心需求
- 保持简单可维护
- 节省开发时间

### 技巧 4：模式引用

**理论**：引用已知的设计模式或最佳实践，确保代码质量。

#### 示例 1：设计模式

```
请使用 Repository 模式重构我的数据访问层：

目标：
- 创建统一的数据访问接口
- 隔离业务逻辑和数据存储细节
- 便于单元测试（可以 mock Repository）
- 支持切换不同的数据源（LocalStorage / API / IndexedDB）

参考：
- Martin Fowler 的 Repository 模式定义
- 实现 IRepository 接口
- 支持泛型（TypeScript）

当前代码：
[贴上现有的数据访问代码]
```

#### 示例 2：架构模式

```
使用 MVVM 模式重构这个页面：

要求：
- Model: 数据和业务逻辑
- View: UI 展示（纯函数）
- ViewModel: 连接 Model 和 View，处理用户交互

参考 Vue.js 的响应式设计思想，但用原生 JS 实现

当前代码：
[贴上混乱的代码]
```

#### 示例 3：最佳实践

```
按照 React 最佳实践重构这个组件：

要点：
- 使用函数组件 + Hooks（不用 Class）
- 职责单一（拆分大组件）
- Props 类型校验（TypeScript 或 PropTypes）
- 合理使用 useMemo / useCallback（避免不必要的重渲染）
- 自定义 Hook 复用逻辑
- 错误边界处理

参考官方文档的风格：
https://react.dev/learn/thinking-in-react
```

### 技巧 5：条件分支

**理论**：根据不同条件给出不同指令，让 AI 做出灵活的决策。

#### 模板

```
如果 [条件A]，则 [做法A]
否则如果 [条件B]，则 [做法B]
否则 [默认做法]
```

#### 示例

```
创建一个通用的 API 请求函数，根据环境变量自动配置：

如果是开发环境（NODE_ENV === 'development'）：
- Base URL: http://localhost:3000
- 打印详细的请求日志（请求参数、响应数据、耗时）
- 不进行请求缓存
- 超时时间：30秒（方便调试）
- 显示详细的错误信息

如果是生产环境（NODE_ENV === 'production'）：
- Base URL: https://api.example.com
- 只打印错误日志
- 启用请求缓存（5分钟）
- 超时时间：10秒
- 用户友好的错误提示（不暴露技术细节）
- 启用请求重试（最多3次）

如果是测试环境（NODE_ENV === 'test'）：
- 使用 Mock 数据（不发起真实请求）
- 打印所有请求（便于测试验证）
- 可配置延迟（模拟网络延迟）
```

### 技巧 6：输出格式要求

**理论**：明确指定输出格式，确保结果符合需求。

#### 示例

```
分析这段代码的性能问题，输出格式如下：

## 性能问题清单

| 问题 | 严重程度 | 当前影响 | 预期收益 |
|-----|---------|---------|---------|
| [问题1] | 🔴 高 | [描述] | [描述] |
| [问题2] | 🟡 中 | [描述] | [描述] |
| [问题3] | 🟢 低 | [描述] | [描述] |

## 优化方案

### 方案1：[标题]
- **优化前**：[代码]
- **优化后**：[代码]
- **收益**：[具体数据]
- **复杂度**：[实施难度]

### 方案2：[标题]
...

## 实施优先级

1. [优先级1] - 预期收益最大
2. [优先级2] - 容易实施
3. [优先级3] - 长期优化

代码：
[贴上代码]
```

## 4. 提示词模板库

### 模板 1：功能开发

```markdown
## 功能需求
[用一两句话描述要开发的功能]

## 用户故事
作为 [角色]
我想要 [功能]
以便于 [目的/价值]

## 详细描述
[详细说明功能细节]

## 验收标准
- [ ] [标准1]
- [ ] [标准2]
- [ ] [标准3]

## 技术要求
- 技术栈：[列出]
- 性能要求：[具体指标]
- 兼容性要求：[浏览器/设备]

## UI/UX 要求
[界面要求或参考设计]

## 约束条件
- [约束1]
- [约束2]

请帮我：
1. 设计技术方案
2. 实现功能代码
3. 编写单元测试
4. 编写使用文档
```

### 模板 2：代码审查

```markdown
请审查以下代码：

```[语言]
[代码]
```

审查维度：
- ✅ 代码质量（可读性、可维护性）
- ✅ 性能（时间复杂度、空间复杂度）
- ✅ 安全性（常见漏洞）
- ✅ 最佳实践（设计模式、编码规范）
- ✅ 错误处理（边界情况、异常处理）

输出格式：
1. 问题清单（按严重程度排序：🔴高 🟡中 🟢低）
2. 每个问题的具体位置和原因
3. 修改建议和优化后的代码
4. 总体评价和改进建议
```

### 模板 3：Bug 修复

```markdown
## Bug 描述
[详细描述 Bug 现象]

## 复现步骤
1. [步骤1]
2. [步骤2]
3. [步骤3]

## 预期行为
[应该怎样]

## 实际行为
[实际怎样]

## 错误信息
```
[完整的错误堆栈]
```

## 环境信息
- 浏览器/Node 版本：
- 操作系统：
- 框架版本：

## 相关代码
```[语言]
[贴上相关代码]
```

请帮我：
1. 分析根本原因（不只是表面现象）
2. 提供修复方案（考虑多种方案）
3. 实施修复（提供修改后的代码）
4. 添加测试（防止问题复现）
5. 补充文档（记录这个问题）
```

### 模板 4：性能优化

```markdown
## 性能问题
[描述性能问题]

## 性能指标
- 当前性能：[数据]
- 目标性能：[数据]
- 瓶颈操作：[描述]

## 环境信息
- 数据量：[规模]
- 并发量：[数量]
- 技术栈：[列出]

## 代码
```[语言]
[贴上代码]
```

请帮我：
1. 分析性能瓶颈（用数据说话）
2. 提供优化方案（至少3个方案）
3. 对比方案优劣（性能提升 vs 实施成本）
4. 实现最佳方案
5. 性能测试验证
```

### 模板 5：架构设计

```markdown
## 项目背景
- 项目类型：[描述]
- 业务规模：[用户量、数据量]
- 团队规模：[人数、技能水平]

## 功能需求
[核心功能列表]

## 非功能需求
- 性能：[响应时间、吞吐量]
- 可用性：[SLA 要求]
- 扩展性：[预期增长]
- 安全性：[安全要求]

## 技术约束
- 技术栈限制：[列出]
- 成本预算：[金额]
- 时间限制：[周期]

请帮我设计：
1. 系统架构图
2. 技术选型方案（包含选型理由）
3. 核心模块设计
4. 数据流设计
5. 部署方案
6. 风险评估和应对策略
```

## 5. 最佳实践总结

### ✅ 应该做的 (Dos)

1. **明确具体** - 提供清晰的需求和详细的上下文
2. **结构化** - 使用清晰的格式组织信息
3. **提供示例** - 给出参考代码或效果
4. **逐步迭代** - 分步完成复杂任务
5. **及时反馈** - 告诉 AI 哪里好、哪里需要改进
6. **使用模板** - 建立自己的提示词模板库
7. **设定角色** - 让 AI 扮演专家角色
8. **善用约束** - 明确不要做什么

### ❌ 不应该做的 (Don'ts)

1. **模糊不清** - "做个好看的东西"
2. **一次太多** - 一次提出 20 个要求
3. **缺少上下文** - 不说明项目背景和约束
4. **不给反馈** - AI 不知道对不对
5. **期望过高** - AI 不能一次完美解决所有问题
6. **忽视验证** - 不测试 AI 生成的代码
7. **过度依赖** - 不理解代码就直接使用

## 6. 进阶资源

### 推荐阅读

1. **提示工程指南**
   - OpenAI Prompt Engineering Guide
   - Anthropic Prompt Design Documentation

2. **实战案例**
   - Awesome ChatGPT Prompts
   - Claude Code Examples

### 练习任务

#### 任务 1：改写提示词

将以下模糊提示词改写为优秀提示词：

1. "做一个登录页面"
2. "优化网站性能"
3. "修复这个bug"

#### 任务 2：创建个人模板库

创建 5 个适合你工作的提示词模板：
- 功能开发模板
- Bug 修复模板
- 代码审查模板
- 性能优化模板
- 技术调研模板

#### 任务 3：实战测试

用优化后的提示词重新完成一个之前的项目，对比：
- 对话轮次
- 代码质量
- 完成时间

## 7. 总结

掌握提示词优化，你的开发效率可以提升 10 倍：

**核心要点**：
1. 提示词质量 = 输出质量
2. 六大原则：具体、结构化、丰富上下文、示例、迭代、反馈
3. 五大技巧：角色、思维链、约束、模式、条件
4. 建立个人模板库
5. 持续实践和优化

**效率提升路径**：
- 新手：提升 2-3 倍（掌握基本原则）
- 熟练：提升 5-7 倍（掌握高级技巧）
- 专家：提升 10 倍+（建立完整体系）

---

💡 **下一步**：
- 实践六大原则
- 创建个人模板库
- 持续优化和迭代

👉 **下一课**：[第十课：AI 子代理系统](./10-AI子代理系统.md)

学习如何使用专业化的 AI 子代理，实现团队协作式开发。
