# 第七课：进阶技巧和最佳实践

> 🎯 **学习目标**：掌握高级开发技巧，提升代码质量和开发效率

## 1. 提示词优化技巧

### 精确描述需求

**❌ 模糊的提示**：
```
做一个网站
```

**✅ 精确的提示**：
```
创建一个电商产品展示页面，要求：
- 使用卡片布局，每行 3 个产品
- 每个产品卡片包含：图片（16:9）、标题、价格、评分
- 鼠标悬停时卡片轻微上浮并显示阴影
- 点击卡片跳转到详情页
- 使用蓝白配色方案
- 响应式设计，手机上每行显示 1 个
```

### 分步骤指导

**提示模板**：
```
第一步：[具体任务]
第二步：[具体任务]
第三步：[具体任务]

每完成一步后等我确认再继续
```

**示例**：
```
帮我重构这个登录模块，分三步进行：
第一步：提取表单验证逻辑为独立函数
第二步：优化错误处理机制
第三步：添加单元测试

完成第一步后暂停，让我review
```

### 提供上下文

```
背景：我正在开发一个在线教育平台
技术栈：React + Node.js + MongoDB
当前问题：用户登录后，课程列表加载很慢
已尝试：添加了loading动画，但还是慢

请帮我分析性能瓶颈并提供优化方案
```

### 使用示例和参考

```
帮我创建一个导航栏，类似 GitHub 的顶部导航：
- 左侧 Logo 和搜索框
- 右侧用户头像和下拉菜单
- 滚动时固定在顶部
- 有轻微的模糊背景效果

参考：https://github.com（描述想要的效果）
```

## 2. 代码审查与优化

### 请求代码审查

```
你：审查这段代码，指出问题和改进建议：

function getUserData(id) {
  fetch('https://api.example.com/users/' + id)
    .then(res => res.json())
    .then(data => {
      console.log(data)
      document.getElementById('user-name').innerHTML = data.name
    })
}

Claude：我发现以下问题：

1. 缺少错误处理
2. 没有检查响应状态
3. 使用 innerHTML 有 XSS 风险
4. 硬编码 DOM ID
5. 没有返回值

改进建议：

async function getUserData(id) {
  try {
    const response = await fetch(`https://api.example.com/users/${id}`)

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }

    const data = await response.json()

    // 安全地更新 DOM
    const userNameEl = document.getElementById('user-name')
    if (userNameEl) {
      userNameEl.textContent = data.name
    }

    return data
  } catch (error) {
    console.error('Failed to fetch user data:', error)
    throw error
  }
}
```

### 性能优化分析

```
你：这段代码有性能问题，帮我优化：

function filterProducts(products, keyword) {
  let result = []
  for (let i = 0; i < products.length; i++) {
    for (let j = 0; j < products[i].tags.length; j++) {
      if (products[i].tags[j].includes(keyword)) {
        result.push(products[i])
        break
      }
    }
  }
  return result
}

Claude：问题分析：
1. 嵌套循环，时间复杂度 O(n*m)
2. 可以使用更简洁的数组方法

优化方案 1（更清晰）：
function filterProducts(products, keyword) {
  return products.filter(product =>
    product.tags.some(tag => tag.includes(keyword))
  )
}

优化方案 2（更快，如果数据量大）：
function filterProducts(products, keyword) {
  const result = []
  const lowerKeyword = keyword.toLowerCase()

  for (const product of products) {
    if (product.tags.some(tag =>
      tag.toLowerCase().includes(lowerKeyword)
    )) {
      result.push(product)
    }
  }

  return result
}

性能对比：
- 原代码：~450ms（10000条数据）
- 优化后：~180ms（60% 提升）
```

### 代码重构建议

```
你：这个组件太长了（300行），帮我重构

Claude：分析代码结构后，建议拆分为：

原组件：UserDashboard.js (300行)

重构后：
components/
├── UserDashboard.js (主容器，50行)
├── UserProfile.js (个人信息，60行)
├── UserStats.js (统计数据，40行)
├── ActivityFeed.js (活动流，80行)
└── SettingsPanel.js (设置面板，70行)

优势：
- 每个组件职责单一
- 便于测试
- 可复用性高
- 易于维护

要我开始重构吗？
```

## 3. 调试技巧

### 系统化调试流程

```
你：登录功能不工作，不知道哪里错了

Claude：让我们系统性地排查：

第一步：复现问题
- 你执行了什么操作？
- 看到什么错误信息？
- 是否打开了浏览器控制台？

第二步：检查前端
1. 检查表单数据是否正确收集
2. 检查请求是否发送
3. 检查请求参数格式

第三步：检查网络
1. 查看 Network 标签
2. 检查请求状态码
3. 查看响应内容

第四步：检查后端
1. 查看服务器日志
2. 检查路由是否正确
3. 验证数据库查询

我会帮你逐步检查每个环节...
```

### 添加调试代码

```
你：帮我添加详细的日志，方便调试

Claude：
为你的代码添加结构化日志：

// 之前
async function loginUser(credentials) {
  const response = await api.login(credentials)
  setUser(response.user)
}

// 之后
async function loginUser(credentials) {
  console.group('🔐 User Login')
  console.log('Credentials:', { ...credentials, password: '***' })

  try {
    console.time('API Call')
    const response = await api.login(credentials)
    console.timeEnd('API Call')

    console.log('Response:', response)

    if (response.user) {
      setUser(response.user)
      console.log('✅ Login successful')
    }
  } catch (error) {
    console.error('❌ Login failed:', error)
    throw error
  } finally {
    console.groupEnd()
  }
}

添加的调试功能：
- 分组日志（便于折叠）
- 性能计时
- 敏感信息保护
- 清晰的成功/失败标识
```

### 断点调试指导

```
你：教我如何使用断点调试

Claude：
设置断点的方法：

方法 1：浏览器开发者工具
1. 打开 Sources 标签
2. 找到你的 JS 文件
3. 点击行号设置断点
4. 刷新页面触发断点

方法 2：代码中添加
debugger;  // 程序会在这里暂停

方法 3：条件断点
右键行号 → 添加条件断点
例如：userId === 123

调试时的操作：
- F8：继续执行
- F10：单步跳过
- F11：单步进入
- 鼠标悬停查看变量值
- Console 中可以执行代码

实例：调试登录函数
function login(username, password) {
  debugger;  // 暂停在这里
  const user = findUser(username);
  debugger;  // 检查 user 的值
  if (validatePassword(user, password)) {
    debugger;  // 检查验证结果
    return createSession(user);
  }
}
```

## 4. 设计模式应用

### 单例模式

```
你：创建一个全局配置管理器，确保只有一个实例

Claude：
使用单例模式：

class Config {
  static instance = null;

  constructor() {
    if (Config.instance) {
      return Config.instance;
    }

    this.settings = {
      apiUrl: 'https://api.example.com',
      theme: 'light',
      language: 'zh-CN'
    };

    Config.instance = this;
  }

  get(key) {
    return this.settings[key];
  }

  set(key, value) {
    this.settings[key] = value;
  }
}

// 使用
const config1 = new Config();
const config2 = new Config();
console.log(config1 === config2);  // true

// 或者使用更简洁的方式
const config = {
  settings: {
    apiUrl: 'https://api.example.com',
    theme: 'light'
  },

  get(key) {
    return this.settings[key];
  },

  set(key, value) {
    this.settings[key] = value;
  }
};

export default config;
```

### 观察者模式

```
你：实现一个事件系统，当数据更新时通知所有订阅者

Claude：
实现观察者模式：

class EventEmitter {
  constructor() {
    this.events = {};
  }

  // 订阅事件
  on(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);

    // 返回取消订阅函数
    return () => this.off(event, callback);
  }

  // 取消订阅
  off(event, callback) {
    if (!this.events[event]) return;

    this.events[event] = this.events[event]
      .filter(cb => cb !== callback);
  }

  // 触发事件
  emit(event, data) {
    if (!this.events[event]) return;

    this.events[event].forEach(callback => {
      callback(data);
    });
  }

  // 只订阅一次
  once(event, callback) {
    const onceCallback = (data) => {
      callback(data);
      this.off(event, onceCallback);
    };
    this.on(event, onceCallback);
  }
}

// 使用示例
const emitter = new EventEmitter();

// 订阅用户登录事件
emitter.on('user:login', (user) => {
  console.log('用户登录:', user.name);
  updateUI(user);
});

emitter.on('user:login', (user) => {
  console.log('记录日志');
  logActivity(user);
});

// 触发事件
emitter.emit('user:login', { name: '张三', id: 123 });
```

### 工厂模式

```
你：创建不同类型的表单控件（输入框、下拉框、日期选择器）

Claude：
使用工厠模式：

class FormFieldFactory {
  static createField(type, config) {
    switch (type) {
      case 'text':
        return new TextField(config);
      case 'select':
        return new SelectField(config);
      case 'date':
        return new DateField(config);
      case 'checkbox':
        return new CheckboxField(config);
      default:
        throw new Error(`Unknown field type: ${type}`);
    }
  }
}

// 基础字段类
class FormField {
  constructor(config) {
    this.name = config.name;
    this.label = config.label;
    this.required = config.required || false;
  }

  validate() {
    if (this.required && !this.value) {
      return `${this.label} 是必填项`;
    }
    return null;
  }

  render() {
    // 子类实现
  }
}

// 文本输入框
class TextField extends FormField {
  render() {
    return `
      <div class="form-field">
        <label>${this.label}</label>
        <input type="text" name="${this.name}"
               ${this.required ? 'required' : ''}>
      </div>
    `;
  }
}

// 下拉框
class SelectField extends FormField {
  constructor(config) {
    super(config);
    this.options = config.options || [];
  }

  render() {
    const optionsHTML = this.options
      .map(opt => `<option value="${opt.value}">${opt.label}</option>`)
      .join('');

    return `
      <div class="form-field">
        <label>${this.label}</label>
        <select name="${this.name}" ${this.required ? 'required' : ''}>
          ${optionsHTML}
        </select>
      </div>
    `;
  }
}

// 使用
const nameField = FormFieldFactory.createField('text', {
  name: 'username',
  label: '用户名',
  required: true
});

const cityField = FormFieldFactory.createField('select', {
  name: 'city',
  label: '城市',
  options: [
    { value: 'bj', label: '北京' },
    { value: 'sh', label: '上海' }
  ]
});
```

## 5. 错误处理最佳实践

### 统一错误处理

```
你：创建一个统一的错误处理系统

Claude：
实现全局错误处理：

// 错误类型定义
class AppError extends Error {
  constructor(message, statusCode, code) {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.isOperational = true;
  }
}

class ValidationError extends AppError {
  constructor(message, field) {
    super(message, 400, 'VALIDATION_ERROR');
    this.field = field;
  }
}

class AuthError extends AppError {
  constructor(message) {
    super(message, 401, 'AUTH_ERROR');
  }
}

class NotFoundError extends AppError {
  constructor(resource) {
    super(`${resource} not found`, 404, 'NOT_FOUND');
    this.resource = resource;
  }
}

// 错误处理器
class ErrorHandler {
  static handle(error) {
    if (error.isOperational) {
      return this.handleOperationalError(error);
    }
    return this.handleProgrammerError(error);
  }

  static handleOperationalError(error) {
    // 用户友好的错误提示
    const message = this.getUserMessage(error);
    this.showNotification(message, 'error');

    // 记录日志
    console.error('[Operational Error]', {
      message: error.message,
      code: error.code,
      stack: error.stack
    });
  }

  static handleProgrammerError(error) {
    // 严重错误，需要开发者关注
    console.error('[Programmer Error]', error);

    // 显示通用错误信息
    this.showNotification(
      '发生了一个错误，请刷新页面重试',
      'error'
    );

    // 可以发送到错误监控服务
    // this.reportToSentry(error);
  }

  static getUserMessage(error) {
    const messages = {
      'VALIDATION_ERROR': `输入验证失败: ${error.message}`,
      'AUTH_ERROR': '认证失败，请重新登录',
      'NOT_FOUND': '请求的资源不存在',
      'NETWORK_ERROR': '网络连接失败，请检查网络'
    };

    return messages[error.code] || '操作失败，请稍后重试';
  }

  static showNotification(message, type) {
    // 实现通知UI
    console.log(`[${type.toUpperCase()}]`, message);
  }
}

// 全局错误捕获
window.addEventListener('error', (event) => {
  ErrorHandler.handle(event.error);
});

window.addEventListener('unhandledrejection', (event) => {
  ErrorHandler.handle(event.reason);
});

// 使用示例
async function login(username, password) {
  try {
    if (!username) {
      throw new ValidationError('用户名不能为空', 'username');
    }

    const response = await api.login(username, password);

    if (!response.ok) {
      throw new AuthError('用户名或密码错误');
    }

    return response.data;
  } catch (error) {
    ErrorHandler.handle(error);
    throw error;  // 如果需要继续传播
  }
}
```

### API 请求错误处理

```
你：创建一个健壮的 API 请求函数，处理各种错误情况

Claude：
实现带重试和超时的 API 请求：

class APIClient {
  constructor(baseURL, options = {}) {
    this.baseURL = baseURL;
    this.timeout = options.timeout || 10000;
    this.retryCount = options.retryCount || 3;
    this.retryDelay = options.retryDelay || 1000;
  }

  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    let lastError;

    // 重试逻辑
    for (let attempt = 0; attempt < this.retryCount; attempt++) {
      try {
        // 添加超时控制
        const response = await Promise.race([
          fetch(url, {
            ...options,
            headers: {
              'Content-Type': 'application/json',
              ...this.getAuthHeaders(),
              ...options.headers
            }
          }),
          this.timeout(this.timeout)
        ]);

        // 检查响应状态
        if (!response.ok) {
          throw await this.handleHTTPError(response);
        }

        return await response.json();

      } catch (error) {
        lastError = error;

        // 判断是否应该重试
        if (!this.shouldRetry(error, attempt)) {
          break;
        }

        // 等待后重试
        await this.delay(this.retryDelay * (attempt + 1));
        console.log(`Retrying... (${attempt + 1}/${this.retryCount})`);
      }
    }

    // 所有重试都失败
    throw lastError;
  }

  // 超时Promise
  timeoutPromise(ms) {
    return new Promise((_, reject) =>
      setTimeout(() => reject(new Error('Request timeout')), ms)
    );
  }

  // 延迟函数
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // 判断是否应该重试
  shouldRetry(error, attempt) {
    // 达到最大重试次数
    if (attempt >= this.retryCount - 1) {
      return false;
    }

    // 网络错误或超时，可以重试
    if (error.message === 'Request timeout' ||
        error.message === 'Failed to fetch') {
      return true;
    }

    // 5xx 服务器错误，可以重试
    if (error.statusCode >= 500) {
      return true;
    }

    // 4xx 客户端错误，不重试
    return false;
  }

  // 处理 HTTP 错误
  async handleHTTPError(response) {
    let errorData;
    try {
      errorData = await response.json();
    } catch {
      errorData = { message: response.statusText };
    }

    const error = new Error(errorData.message || 'Request failed');
    error.statusCode = response.status;
    error.response = errorData;

    return error;
  }

  // 获取认证头
  getAuthHeaders() {
    const token = localStorage.getItem('auth_token');
    return token ? { 'Authorization': `Bearer ${token}` } : {};
  }

  // 便捷方法
  get(endpoint, options) {
    return this.request(endpoint, { ...options, method: 'GET' });
  }

  post(endpoint, data, options) {
    return this.request(endpoint, {
      ...options,
      method: 'POST',
      body: JSON.stringify(data)
    });
  }

  put(endpoint, data, options) {
    return this.request(endpoint, {
      ...options,
      method: 'PUT',
      body: JSON.stringify(data)
    });
  }

  delete(endpoint, options) {
    return this.request(endpoint, { ...options, method: 'DELETE' });
  }
}

// 使用
const api = new APIClient('https://api.example.com', {
  timeout: 5000,
  retryCount: 3,
  retryDelay: 1000
});

// 示例请求
try {
  const users = await api.get('/users');
  const newUser = await api.post('/users', { name: '张三' });
} catch (error) {
  console.error('API请求失败:', error);
}
```

## 6. 安全最佳实践

### 输入验证和清理

```
你：创建安全的输入验证函数，防止 XSS 和注入攻击

Claude：
实现输入验证和清理：

class InputValidator {
  // 清理 HTML，防止 XSS
  static sanitizeHTML(input) {
    const map = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;'
    };
    return input.replace(/[&<>"'/]/g, char => map[char]);
  }

  // 验证邮箱
  static isValidEmail(email) {
    const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return regex.test(email);
  }

  // 验证密码强度
  static isStrongPassword(password) {
    // 至少8位，包含大小写字母、数字和特殊字符
    const regex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
    return regex.test(password);
  }

  // 验证用户名
  static isValidUsername(username) {
    // 3-20位，只能包含字母、数字、下划线
    const regex = /^[a-zA-Z0-9_]{3,20}$/;
    return regex.test(username);
  }

  // 防止 SQL 注入（前端验证）
  static containsSQLInjection(input) {
    const sqlPatterns = [
      /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|EXECUTE)\b)/i,
      /(--|\#|\/\*|\*\/)/,
      /(\bOR\b|\bAND\b).*=.*=/i
    ];

    return sqlPatterns.some(pattern => pattern.test(input));
  }

  // 综合验证
  static validate(input, rules) {
    const errors = [];

    if (rules.required && !input) {
      errors.push('此字段必填');
    }

    if (rules.minLength && input.length < rules.minLength) {
      errors.push(`最少${rules.minLength}个字符`);
    }

    if (rules.maxLength && input.length > rules.maxLength) {
      errors.push(`最多${rules.maxLength}个字符`);
    }

    if (rules.email && !this.isValidEmail(input)) {
      errors.push('邮箱格式不正确');
    }

    if (rules.strongPassword && !this.isStrongPassword(input)) {
      errors.push('密码强度不够');
    }

    if (rules.noSQLInjection && this.containsSQLInjection(input)) {
      errors.push('输入包含非法字符');
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }
}

// 使用示例
const username = userInput.username;
const validation = InputValidator.validate(username, {
  required: true,
  minLength: 3,
  maxLength: 20,
  noSQLInjection: true
});

if (!validation.valid) {
  console.error('验证失败:', validation.errors);
}

// 清理用户输入用于显示
const safeContent = InputValidator.sanitizeHTML(userInput.content);
document.getElementById('output').textContent = safeContent;
```

### 安全存储敏感信息

```
你：如何安全地存储用户令牌和敏感信息？

Claude：
安全存储最佳实践：

class SecureStorage {
  // 不要将敏感信息存在 localStorage（易被 XSS 攻击）
  // 使用 httpOnly cookie 或内存存储

  constructor() {
    // 内存存储（刷新页面会丢失）
    this.memoryStorage = new Map();
  }

  // 存储敏感信息到内存
  setSecure(key, value) {
    this.memoryStorage.set(key, value);
  }

  // 获取敏感信息
  getSecure(key) {
    return this.memoryStorage.get(key);
  }

  // 清除敏感信息
  clearSecure(key) {
    this.memoryStorage.delete(key);
  }

  // 非敏感信息可以用 localStorage（加密）
  setLocal(key, value) {
    try {
      const encrypted = this.encrypt(JSON.stringify(value));
      localStorage.setItem(key, encrypted);
    } catch (error) {
      console.error('存储失败:', error);
    }
  }

  getLocal(key) {
    try {
      const encrypted = localStorage.getItem(key);
      if (!encrypted) return null;

      const decrypted = this.decrypt(encrypted);
      return JSON.parse(decrypted);
    } catch (error) {
      console.error('读取失败:', error);
      return null;
    }
  }

  // 简单的加密（仅用于演示，生产环境应使用专业加密库）
  encrypt(text) {
    // 使用 Web Crypto API 或专业库如 crypto-js
    return btoa(text);  // 简化示例
  }

  decrypt(encrypted) {
    return atob(encrypted);  // 简化示例
  }

  // 使用 sessionStorage（标签页关闭后清除）
  setSession(key, value) {
    sessionStorage.setItem(key, JSON.stringify(value));
  }

  getSession(key) {
    const value = sessionStorage.getItem(key);
    return value ? JSON.parse(value) : null;
  }
}

// 最佳实践
const storage = new SecureStorage();

// ✅ 认证令牌存在内存或 httpOnly cookie
storage.setSecure('auth_token', token);

// ✅ 用户偏好可以存 localStorage（加密）
storage.setLocal('preferences', {
  theme: 'dark',
  language: 'zh-CN'
});

// ❌ 不要这样做
localStorage.setItem('password', password);  // 永远不要存密码
localStorage.setItem('credit_card', cardNumber);  // 不要存敏感信息
```

### CSP (Content Security Policy)

```
你：如何配置 CSP 提高安全性？

Claude：
添加 CSP 头部：

在 HTML 中：
<meta http-equiv="Content-Security-Policy"
      content="default-src 'self';
               script-src 'self' https://trusted-cdn.com;
               style-src 'self' 'unsafe-inline';
               img-src 'self' data: https:;
               font-src 'self' https://fonts.gstatic.com;
               connect-src 'self' https://api.example.com;
               frame-ancestors 'none';
               base-uri 'self';
               form-action 'self';">

或在服务器配置（Express）：
const helmet = require('helmet');

app.use(helmet.contentSecurityPolicy({
  directives: {
    defaultSrc: ["'self'"],
    scriptSrc: ["'self'", "https://trusted-cdn.com"],
    styleSrc: ["'self'", "'unsafe-inline'"],
    imgSrc: ["'self'", "data:", "https:"],
    connectSrc: ["'self'", "https://api.example.com"],
    fontSrc: ["'self'", "https://fonts.gstatic.com"],
    objectSrc: ["'none'"],
    upgradeInsecureRequests: []
  }
}));

CSP 规则说明：
- default-src 'self'：默认只允许同源资源
- script-src：限制 JavaScript 来源
- style-src：限制 CSS 来源
- img-src：限制图片来源
- connect-src：限制 AJAX/WebSocket 连接
- frame-ancestors 'none'：防止被嵌入 iframe
```

## 7. 性能监控

### 实现性能追踪

```
你：创建一个性能监控系统

Claude：
实现性能监控：

class PerformanceMonitor {
  constructor() {
    this.metrics = {};
  }

  // 测量函数执行时间
  measure(name, fn) {
    return async (...args) => {
      const start = performance.now();

      try {
        const result = await fn(...args);
        const duration = performance.now() - start;

        this.record(name, duration);
        return result;
      } catch (error) {
        const duration = performance.now() - start;
        this.record(name, duration, 'error');
        throw error;
      }
    };
  }

  // 记录指标
  record(name, duration, status = 'success') {
    if (!this.metrics[name]) {
      this.metrics[name] = {
        count: 0,
        totalTime: 0,
        avgTime: 0,
        minTime: Infinity,
        maxTime: 0,
        errors: 0
      };
    }

    const metric = this.metrics[name];
    metric.count++;
    metric.totalTime += duration;
    metric.avgTime = metric.totalTime / metric.count;
    metric.minTime = Math.min(metric.minTime, duration);
    metric.maxTime = Math.max(metric.maxTime, duration);

    if (status === 'error') {
      metric.errors++;
    }

    // 性能警告
    if (duration > 1000) {
      console.warn(`⚠️ 性能警告: ${name} 耗时 ${duration.toFixed(2)}ms`);
    }
  }

  // 监控页面加载性能
  measurePageLoad() {
    if (window.performance) {
      const timing = performance.timing;
      const metrics = {
        // DNS 查询时间
        dns: timing.domainLookupEnd - timing.domainLookupStart,
        // TCP 连接时间
        tcp: timing.connectEnd - timing.connectStart,
        // 请求响应时间
        request: timing.responseEnd - timing.requestStart,
        // DOM 解析时间
        domParse: timing.domInteractive - timing.domLoading,
        // 资源加载时间
        resourceLoad: timing.loadEventStart - timing.domContentLoadedEventEnd,
        // 总加载时间
        total: timing.loadEventEnd - timing.navigationStart
      };

      console.table(metrics);
      return metrics;
    }
  }

  // 监控 API 请求
  monitorAPI(apiClient) {
    const originalRequest = apiClient.request.bind(apiClient);

    apiClient.request = async (endpoint, options) => {
      const start = performance.now();

      try {
        const result = await originalRequest(endpoint, options);
        const duration = performance.now() - start;

        this.record(`API: ${endpoint}`, duration);
        return result;
      } catch (error) {
        const duration = performance.now() - start;
        this.record(`API: ${endpoint}`, duration, 'error');
        throw error;
      }
    };
  }

  // 生成报告
  generateReport() {
    console.group('📊 性能报告');

    Object.entries(this.metrics).forEach(([name, metric]) => {
      console.group(name);
      console.log(`调用次数: ${metric.count}`);
      console.log(`平均耗时: ${metric.avgTime.toFixed(2)}ms`);
      console.log(`最短耗时: ${metric.minTime.toFixed(2)}ms`);
      console.log(`最长耗时: ${metric.maxTime.toFixed(2)}ms`);
      console.log(`错误次数: ${metric.errors}`);
      console.groupEnd();
    });

    console.groupEnd();

    return this.metrics;
  }

  // 清空指标
  reset() {
    this.metrics = {};
  }
}

// 使用示例
const monitor = new PerformanceMonitor();

// 包装需要监控的函数
const fetchUsers = monitor.measure('fetchUsers', async () => {
  const response = await fetch('/api/users');
  return response.json();
});

// 监控 API 客户端
monitor.monitorAPI(apiClient);

// 页面加载时监控
window.addEventListener('load', () => {
  monitor.measurePageLoad();
});

// 定期生成报告
setInterval(() => {
  monitor.generateReport();
}, 60000);  // 每分钟
```

## 8. 下一步

👉 下一课：[Claude Code 高级应用](./08-高级应用.md)

学习更多高级话题：
- 与 AI 协作的高级技巧
- 复杂项目架构设计
- 自动化测试和 CI/CD
- 多语言项目开发

---

💡 **本课要点回顾**：
- 提示词优化能大幅提升效率
- 代码审查和重构是持续的过程
- 系统化的调试方法很重要
- 设计模式提高代码质量
- 安全永远是第一位的
- 性能监控帮助发现问题
