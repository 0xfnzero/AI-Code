# 第八课：Claude Code 高级应用

> 🎯 **学习目标**：掌握与 AI 协作的高级技巧，构建复杂项目

## 1. 高效协作模式

### AI Pair Programming（AI 结对编程）

**TDD 模式（测试驱动开发）**：
```
你：我要实现一个购物车功能，我们用 TDD 方式开发

Claude：好的，让我们先写测试：

describe('ShoppingCart', () => {
  test('should add item to cart', () => {
    const cart = new ShoppingCart()
    cart.addItem({ id: 1, name: 'Book', price: 29.99 })
    expect(cart.items.length).toBe(1)
  })

  test('should calculate total price', () => {
    const cart = new ShoppingCart()
    cart.addItem({ id: 1, price: 10 })
    cart.addItem({ id: 2, price: 20 })
    expect(cart.getTotal()).toBe(30)
  })
})

测试写好了，现在实现功能吗？

你：是的，实现最简单能通过测试的代码

Claude：[实现 ShoppingCart 类]

你：测试通过了！现在重构代码，让它更优雅

Claude：[优化实现]
```

### 渐进式重构

```
你：我有一个旧项目，想重构但不能影响现有功能，怎么做？

Claude：使用渐进式重构策略：

第一阶段：添加测试
1. 为现有功能编写测试
2. 确保测试覆盖率 > 80%
3. 建立测试基准

第二阶段：识别问题
1. 分析代码异味（Code Smells）
2. 识别重复代码
3. 找出过度复杂的部分

第三阶段：小步重构
1. 每次只重构一个模块
2. 保持测试通过
3. 频繁提交

第四阶段：渐进替换
1. 新功能用新架构
2. 旧功能逐步迁移
3. Strangler Pattern（绞杀者模式）

我们从哪个模块开始？
```

### 代码审查协作

```
你：帮我审查这次 Pull Request，给出专业的代码审查意见

Claude：代码审查报告：

✅ 优点：
1. 代码结构清晰，模块划分合理
2. 有完整的单元测试
3. 错误处理完善

⚠️ 需要改进：
1. 函数过长（line 45-120），建议拆分
2. 缺少类型注解（如果使用 TypeScript）
3. 部分变量命名不够语义化（如 data, temp）

🔴 问题：
1. 潜在的内存泄漏：addEventListener 没有清理
2. SQL 查询没有参数化，有注入风险
3. 同步阻塞操作（line 78）应改为异步

📝 建议：
1. 添加 JSDoc 注释
2. 考虑使用设计模式重构（建议：Strategy Pattern）
3. 性能：可以添加缓存机制

详细修改建议：
[具体的代码修改]
```

## 2. 复杂项目架构

### 微前端架构

```
你：设计一个微前端架构，多个团队独立开发不同模块

Claude：微前端架构方案：

项目结构：
monorepo/
├── packages/
│   ├── shell/          # 主容器应用
│   ├── module-auth/    # 认证模块
│   ├── module-dashboard/  # 仪表板
│   ├── module-settings/   # 设置
│   └── shared/         # 共享资源
├── lerna.json
└── package.json

Shell 应用（容器）：
// shell/src/app.js
class MicroFrontendContainer {
  constructor() {
    this.modules = new Map()
  }

  // 注册模块
  register(name, moduleFactory) {
    this.modules.set(name, moduleFactory)
  }

  // 加载模块
  async load(name, container) {
    if (!this.modules.has(name)) {
      // 动态加载
      await this.loadModule(name)
    }

    const moduleFactory = this.modules.get(name)
    const module = await moduleFactory()

    module.mount(container)
    return module
  }

  // 动态加载模块
  async loadModule(name) {
    const script = document.createElement('script')
    script.src = `/modules/${name}/index.js`

    return new Promise((resolve, reject) => {
      script.onload = resolve
      script.onerror = reject
      document.head.appendChild(script)
    })
  }
}

模块示例（Dashboard）：
// module-dashboard/src/index.js
export default {
  async mount(container) {
    // 渲染模块
    container.innerHTML = '<div id="dashboard">...</div>'

    // 初始化
    await this.init()
  },

  async unmount(container) {
    // 清理资源
    container.innerHTML = ''
  },

  async init() {
    // 模块初始化逻辑
  }
}

模块通信（Event Bus）：
// shared/eventBus.js
class EventBus {
  constructor() {
    this.events = {}
  }

  publish(event, data) {
    if (this.events[event]) {
      this.events[event].forEach(callback => callback(data))
    }
  }

  subscribe(event, callback) {
    if (!this.events[event]) {
      this.events[event] = []
    }
    this.events[event].push(callback)

    // 返回取消订阅函数
    return () => {
      this.events[event] = this.events[event]
        .filter(cb => cb !== callback)
    }
  }
}

export const eventBus = new EventBus()

使用：
// 模块 A 发布事件
eventBus.publish('user:login', { userId: 123 })

// 模块 B 订阅事件
eventBus.subscribe('user:login', (data) => {
  console.log('User logged in:', data.userId)
  updateUI(data)
})

部署配置：
- 每个模块独立部署
- 使用 CDN 托管模块
- 版本管理和回滚机制
```

### 插件系统设计

```
你：设计一个插件系统，让用户可以扩展应用功能

Claude：插件系统架构：

// 核心：Plugin Manager
class PluginManager {
  constructor() {
    this.plugins = new Map()
    this.hooks = new Map()
  }

  // 注册插件
  register(plugin) {
    // 验证插件
    if (!this.validatePlugin(plugin)) {
      throw new Error('Invalid plugin')
    }

    // 保存插件
    this.plugins.set(plugin.name, plugin)

    // 注册钩子
    if (plugin.hooks) {
      Object.entries(plugin.hooks).forEach(([hook, handler]) => {
        this.registerHook(hook, handler)
      })
    }

    // 调用插件初始化
    if (plugin.init) {
      plugin.init(this.getAPI())
    }

    console.log(`✅ Plugin registered: ${plugin.name}`)
  }

  // 注册钩子
  registerHook(hookName, handler) {
    if (!this.hooks.has(hookName)) {
      this.hooks.set(hookName, [])
    }
    this.hooks.get(hookName).push(handler)
  }

  // 触发钩子
  async trigger(hookName, data) {
    if (!this.hooks.has(hookName)) {
      return data
    }

    let result = data

    for (const handler of this.hooks.get(hookName)) {
      result = await handler(result, this.getAPI())
    }

    return result
  }

  // 提供给插件的 API
  getAPI() {
    return {
      // 数据访问
      getData: (key) => this.appData.get(key),
      setData: (key, value) => this.appData.set(key, value),

      // UI 扩展
      addMenuItem: (item) => this.menu.addItem(item),
      addPage: (route, component) => this.router.addRoute(route, component),

      // 通知
      notify: (message, type) => this.notifications.show(message, type),

      // 工具函数
      http: this.httpClient,
      storage: this.storage
    }
  }

  // 验证插件
  validatePlugin(plugin) {
    return plugin.name && plugin.version
  }

  // 卸载插件
  unregister(pluginName) {
    const plugin = this.plugins.get(pluginName)

    if (plugin && plugin.destroy) {
      plugin.destroy()
    }

    this.plugins.delete(pluginName)

    // 移除钩子
    // ... 清理逻辑
  }
}

// 插件示例 1：主题切换
const themePlugin = {
  name: 'theme-switcher',
  version: '1.0.0',

  init(api) {
    // 添加菜单项
    api.addMenuItem({
      label: '切换主题',
      onClick: () => this.toggleTheme(api)
    })

    // 加载保存的主题
    const savedTheme = api.getData('theme') || 'light'
    this.applyTheme(savedTheme)
  },

  toggleTheme(api) {
    const current = api.getData('theme') || 'light'
    const newTheme = current === 'light' ? 'dark' : 'light'

    this.applyTheme(newTheme)
    api.setData('theme', newTheme)
    api.notify(`已切换到${newTheme === 'light' ? '亮色' : '暗色'}主题`, 'success')
  },

  applyTheme(theme) {
    document.body.classList.remove('theme-light', 'theme-dark')
    document.body.classList.add(`theme-${theme}`)
  }
}

// 插件示例 2：数据导出
const exportPlugin = {
  name: 'data-exporter',
  version: '1.0.0',

  hooks: {
    // 在数据保存前处理
    'before:save': async (data, api) => {
      // 添加元数据
      return {
        ...data,
        exportedAt: new Date().toISOString(),
        exportedBy: api.getData('currentUser')
      }
    }
  },

  init(api) {
    // 添加导出按钮
    api.addMenuItem({
      label: '导出数据',
      onClick: () => this.exportData(api)
    })
  },

  async exportData(api) {
    const data = api.getData('appData')

    // 触发钩子处理数据
    const processedData = await api.trigger('before:save', data)

    // 导出为 JSON
    const blob = new Blob([JSON.stringify(processedData, null, 2)], {
      type: 'application/json'
    })

    const url = URL.createObjectURL(blob)
    const link = document.createElement('a')
    link.href = url
    link.download = `export-${Date.now()}.json`
    link.click()

    api.notify('数据导出成功', 'success')
  }
}

// 使用插件系统
const pluginManager = new PluginManager()

pluginManager.register(themePlugin)
pluginManager.register(exportPlugin)

// 第三方开发者也可以创建插件
const customPlugin = {
  name: 'my-custom-plugin',
  version: '1.0.0',

  init(api) {
    // 自定义功能
  }
}

pluginManager.register(customPlugin)
```

## 3. 自动化测试

### E2E 测试自动化

```
你：为我的 Web 应用创建完整的 E2E 测试

Claude：使用 Playwright 创建 E2E 测试：

// tests/e2e/user-flow.spec.js
const { test, expect } = require('@playwright/test')

test.describe('用户完整流程', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('http://localhost:3000')
  })

  test('用户注册流程', async ({ page }) => {
    // 1. 点击注册按钮
    await page.click('text=注册')

    // 2. 填写表单
    await page.fill('[name="username"]', 'testuser')
    await page.fill('[name="email"]', 'test@example.com')
    await page.fill('[name="password"]', 'Test123!@#')

    // 3. 提交表单
    await page.click('button[type="submit"]')

    // 4. 验证成功消息
    await expect(page.locator('.success-message')).toBeVisible()
    await expect(page.locator('.success-message'))
      .toContainText('注册成功')

    // 5. 验证跳转到仪表板
    await expect(page).toHaveURL(/.*dashboard/)
  })

  test('用户登录流程', async ({ page }) => {
    // 1. 点击登录
    await page.click('text=登录')

    // 2. 填写凭据
    await page.fill('[name="username"]', 'testuser')
    await page.fill('[name="password"]', 'Test123!@#')

    // 3. 提交
    await page.click('button:has-text("登录")')

    // 4. 验证登录成功
    await expect(page.locator('.user-avatar')).toBeVisible()

    // 5. 验证用户名显示
    await expect(page.locator('.username'))
      .toContainText('testuser')
  })

  test('创建任务流程', async ({ page, context }) => {
    // 先登录
    await loginAsUser(page, 'testuser', 'Test123!@#')

    // 1. 点击添加任务
    await page.click('text=添加任务')

    // 2. 填写任务信息
    await page.fill('[name="title"]', '完成测试')
    await page.fill('[name="description"]', '编写E2E测试')
    await page.selectOption('[name="priority"]', 'high')

    // 3. 上传附件（如果有）
    await page.setInputFiles('[name="attachment"]', './test-file.pdf')

    // 4. 提交
    await page.click('button:has-text("创建")')

    // 5. 验证任务出现在列表中
    await expect(page.locator('.task-item:has-text("完成测试")')).toBeVisible()

    // 6. 验证任务详情
    await page.click('.task-item:has-text("完成测试")')
    await expect(page.locator('.task-detail .title'))
      .toContainText('完成测试')
    await expect(page.locator('.task-detail .priority'))
      .toContainText('high')
  })

  test('搜索功能', async ({ page }) => {
    await loginAsUser(page, 'testuser', 'Test123!@#')

    // 1. 输入搜索关键词
    await page.fill('[name="search"]', '测试')

    // 2. 等待搜索结果
    await page.waitForSelector('.search-results')

    // 3. 验证结果
    const results = page.locator('.search-result-item')
    await expect(results).toHaveCount(3)  // 假设有3个结果

    // 4. 点击搜索结果
    await results.first().click()

    // 5. 验证导航到正确页面
    await expect(page).toHaveURL(/.*task/)
  })

  test('响应式设计', async ({ page }) => {
    // 测试移动端
    await page.setViewportSize({ width: 375, height: 667 })

    // 验证移动端菜单
    await expect(page.locator('.mobile-menu-button')).toBeVisible()
    await expect(page.locator('.desktop-sidebar')).not.toBeVisible()

    // 打开移动菜单
    await page.click('.mobile-menu-button')
    await expect(page.locator('.mobile-menu')).toBeVisible()

    // 测试平板
    await page.setViewportSize({ width: 768, height: 1024 })
    // ... 平板布局测试

    // 测试桌面
    await page.setViewportSize({ width: 1920, height: 1080 })
    // ... 桌面布局测试
  })
})

// 辅助函数
async function loginAsUser(page, username, password) {
  await page.goto('http://localhost:3000/login')
  await page.fill('[name="username"]', username)
  await page.fill('[name="password"]', password)
  await page.click('button[type="submit"]')
  await page.waitForURL('**/dashboard')
}

// 配置文件：playwright.config.js
module.exports = {
  testDir: './tests/e2e',
  timeout: 30000,
  use: {
    baseURL: 'http://localhost:3000',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure',
  },
  projects: [
    { name: 'chromium', use: { browserName: 'chromium' } },
    { name: 'firefox', use: { browserName: 'firefox' } },
    { name: 'webkit', use: { browserName: 'webkit' } }
  ]
}

运行测试：
npm run test:e2e
```

### 视觉回归测试

```
你：添加视觉回归测试，检测 UI 变化

Claude：使用 Playwright 的截图对比：

// tests/visual/visual-regression.spec.js
const { test, expect } = require('@playwright/test')

test.describe('视觉回归测试', () => {
  test('首页视觉检查', async ({ page }) => {
    await page.goto('/')

    // 等待页面完全加载
    await page.waitForLoadState('networkidle')

    // 截图对比
    await expect(page).toHaveScreenshot('homepage.png', {
      fullPage: true,
      maxDiffPixels: 100  // 允许的差异像素数
    })
  })

  test('按钮样式检查', async ({ page }) => {
    await page.goto('/components')

    // 截取特定元素
    const button = page.locator('.primary-button')
    await expect(button).toHaveScreenshot('primary-button.png')

    // 悬停状态
    await button.hover()
    await expect(button).toHaveScreenshot('primary-button-hover.png')

    // 激活状态
    await button.focus()
    await expect(button).toHaveScreenshot('primary-button-active.png')
  })

  test('表单布局检查', async ({ page }) => {
    await page.goto('/form')

    // 不同视口大小的截图
    const viewports = [
      { width: 375, height: 667, name: 'mobile' },
      { width: 768, height: 1024, name: 'tablet' },
      { width: 1920, height: 1080, name: 'desktop' }
    ]

    for (const viewport of viewports) {
      await page.setViewportSize(viewport)
      await expect(page).toHaveScreenshot(`form-${viewport.name}.png`)
    }
  })

  test('深色模式检查', async ({ page }) => {
    await page.goto('/')

    // 亮色模式
    await expect(page).toHaveScreenshot('homepage-light.png')

    // 切换到深色模式
    await page.click('[data-theme-toggle]')
    await page.waitForTimeout(500)  // 等待主题切换动画

    // 深色模式
    await expect(page).toHaveScreenshot('homepage-dark.png')
  })
})

// 更新基准截图
// npm run test:visual -- --update-snapshots
```

## 4. CI/CD 集成

### GitHub Actions 配置

```
你：配置 CI/CD 流程，自动测试和部署

Claude：创建 GitHub Actions 工作流：

# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  # 代码质量检查
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        run: npm run lint

      - name: Run Prettier check
        run: npm run format:check

  # 单元测试
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm run test:unit -- --coverage

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/coverage-final.json

  # E2E 测试
  e2e:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm ci

      - name: Install Playwright
        run: npx playwright install --with-deps

      - name: Run E2E tests
        run: npm run test:e2e

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: playwright-report
          path: playwright-report/

  # 构建
  build:
    needs: [lint, test]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm ci

      - name: Build
        run: npm run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: build
          path: dist/

  # 部署到 Staging
  deploy-staging:
    needs: [build, e2e]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    environment:
      name: staging
      url: https://staging.example.com
    steps:
      - name: Download build
        uses: actions/download-artifact@v3
        with:
          name: build
          path: dist/

      - name: Deploy to Staging
        run: |
          # 部署到 staging 服务器
          echo "Deploying to staging..."
          # scp -r dist/* user@staging.example.com:/var/www/html

  # 部署到 Production
  deploy-production:
    needs: [build, e2e]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://example.com
    steps:
      - name: Download build
        uses: actions/download-artifact@v3
        with:
          name: build
          path: dist/

      - name: Deploy to Production
        run: |
          echo "Deploying to production..."
          # 实际部署命令

      - name: Notify Slack
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}

  # 性能测试
  performance:
    needs: [deploy-staging]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    steps:
      - uses: actions/checkout@v3

      - name: Run Lighthouse CI
        run: |
          npm install -g @lhci/cli
          lhci autorun --config=lighthouserc.json

      - name: Upload results
        uses: actions/upload-artifact@v3
        with:
          name: lighthouse-results
          path: .lighthouseci/

# Lighthouse 配置：lighthouserc.json
{
  "ci": {
    "collect": {
      "url": ["https://staging.example.com"],
      "numberOfRuns": 3
    },
    "assert": {
      "assertions": {
        "categories:performance": ["error", {"minScore": 0.9}],
        "categories:accessibility": ["error", {"minScore": 0.9}],
        "categories:best-practices": ["error", {"minScore": 0.9}],
        "categories:seo": ["error", {"minScore": 0.9}]
      }
    },
    "upload": {
      "target": "temporary-public-storage"
    }
  }
}
```

## 5. 多语言项目开发

### Python + FastAPI 后端

```
你：用 Python FastAPI 重写后端API

Claude：创建 FastAPI 后端：

# backend/main.py
from fastapi import FastAPI, HTTPException, Depends
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional
import uvicorn

app = FastAPI(title="Task API", version="1.0.0")

# CORS 配置
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 数据模型
class Task(BaseModel):
    id: Optional[int] = None
    title: str
    description: Optional[str] = None
    completed: bool = False
    priority: str = "medium"

class TaskCreate(BaseModel):
    title: str
    description: Optional[str] = None
    priority: str = "medium"

class TaskUpdate(BaseModel):
    title: Optional[str] = None
    description: Optional[str] = None
    completed: Optional[bool] = None
    priority: Optional[str] = None

# 数据库（示例用内存）
tasks_db = []
next_id = 1

# 路由
@app.get("/")
async def root():
    return {"message": "Task API", "version": "1.0.0"}

@app.get("/api/tasks", response_model=List[Task])
async def get_tasks():
    """获取所有任务"""
    return tasks_db

@app.get("/api/tasks/{task_id}", response_model=Task)
async def get_task(task_id: int):
    """获取单个任务"""
    task = next((t for t in tasks_db if t['id'] == task_id), None)
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    return task

@app.post("/api/tasks", response_model=Task, status_code=201)
async def create_task(task: TaskCreate):
    """创建新任务"""
    global next_id
    new_task = {
        "id": next_id,
        **task.dict()
    }
    tasks_db.append(new_task)
    next_id += 1
    return new_task

@app.put("/api/tasks/{task_id}", response_model=Task)
async def update_task(task_id: int, task: TaskUpdate):
    """更新任务"""
    existing_task = next((t for t in tasks_db if t['id'] == task_id), None)
    if not existing_task:
        raise HTTPException(status_code=404, detail="Task not found")

    # 更新字段
    update_data = task.dict(exclude_unset=True)
    for key, value in update_data.items():
        existing_task[key] = value

    return existing_task

@app.delete("/api/tasks/{task_id}", status_code=204)
async def delete_task(task_id: int):
    """删除任务"""
    global tasks_db
    tasks_db = [t for t in tasks_db if t['id'] != task_id]
    return None

# 健康检查
@app.get("/health")
async def health_check():
    return {"status": "healthy"}

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)

# requirements.txt
fastapi==0.104.1
uvicorn[standard]==0.24.0
pydantic==2.5.0

# 安装和运行
# pip install -r requirements.txt
# python main.py
```

## 6. 总结和展望

### 你已经掌握的技能

✅ **基础技能**
- Claude Code 的使用方法
- 与 AI 有效沟通
- 基本的文件操作

✅ **开发技能**
- 前端开发（HTML/CSS/JavaScript）
- 后端开发（Node.js/Python）
- 数据库操作
- API 设计

✅ **工程实践**
- 代码审查和重构
- 测试（单元测试、E2E测试）
- CI/CD 自动化
- 性能优化

✅ **高级技巧**
- 设计模式应用
- 项目架构设计
- 插件系统
- 多语言开发

### 继续学习的方向

🚀 **深入学习**
- 云原生开发（Docker、Kubernetes）
- 微服务架构
- GraphQL
- 机器学习集成

🎯 **实践项目**
- 开源项目贡献
- 个人作品集网站
- SaaS 产品开发
- 移动应用开发

📚 **推荐资源**
- MDN Web Docs（Web 开发）
- freeCodeCamp（免费编程课程）
- GitHub（开源项目学习）
- Stack Overflow（问题解答）

---

💡 **最后的建议**：
- 保持好奇心，不断学习
- 多做项目，实践是最好的老师
- 参与社区，分享你的经验
- 善用 Claude Code，但理解代码原理
- 写出优雅的代码，而不只是能运行的代码

🎉 **恭喜你完成所有课程！现在，开始创造属于你的项目吧！**
